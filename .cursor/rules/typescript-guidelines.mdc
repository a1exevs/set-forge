---
description: TypeScript strict mode and type safety
alwaysApply: true
---

# TypeScript Guidelines

## Strict Mode

TS strict mode enabled. All strict checks enforced.

## Type Safety Rules

- NEVER use `any`. Use `unknown` + type narrowing when type is unknown.
- Always handle `null`/`undefined` explicitly (optional chaining, nullish coalescing, guards).
- Array index access returns `T | undefined` — always check before use.
- Minimize `as` assertions — prefer type guards or proper typing.
- Use `as const` for literal types.

## Explicit Return Types

ALL functions MUST have explicit return types, including `void`:

```typescript
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

const handleClick = (e: MouseEvent): void => {
  console.log('clicked');
};
```

## Type Definitions

- `interface` — ONLY for business entities (Exercise, User, etc.)
- `type` — for everything else: unions, intersections, props, utility types

## Component Props

See component-typing.

## Type Exports

Use `export type { X }` in barrel files:

```typescript
export type { Exercise, MuscleGroup } from './types';
```

## General Practices

- Use generics for reusable type-safe code
- Use built-in utility types (Omit, Pick, Partial, Required, Readonly)
- Use discriminated unions for complex state
- Create type guards (`value is T`) for runtime checks
- Type React event handlers explicitly (FormEvent, ChangeEvent, MouseEvent)
- Follow `@typescript-eslint` strict rules
